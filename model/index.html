<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>MNIST Quick Test (with proper preprocessing)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- TF.js (modern) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
  <!-- OpenCV.js (official CDN) -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="cvReady()" ></script>
  <style>
    :root{--accent:#00b894; --bar:#4a90e2;}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:20px;color:#222}
    h1{margin:0 0 12px}
    #wrap{display:flex;gap:24px;align-items:flex-start;flex-wrap:wrap}
    #pad{border:2px solid #333;background:#000;touch-action:none}
    #preview{border:1px dashed #888;width:56px;height:56px;image-rendering:pixelated}
    button{padding:6px 12px;margin-right:8px}
    .row{display:grid;grid-template-columns:20px 1fr 52px;gap:6px;align-items:center}
    .bar{height:10px;background:var(--bar)}
    #status{margin-top:8px;color:#666}
  </style>
</head>
<body>
<h1>MNIST Canvas Quick Test</h1>

<div id="wrap">
  <div>
    <!-- Drawing canvas: black bg, white ink -->
    <canvas id="pad" width="280" height="280"></canvas>
    <div style="margin-top:10px">
      <button id="btnPredict">Predict</button>
      <button id="btnClear">Clear</button>
      <label style="margin-left:8px">
        Blur(px): <input id="blurPx" type="number" step="0.1" min="0" max="2" value="0.5" style="width:64px">
      </label>
    </div>
    <div id="status">Loading OpenCV…</div>
  </div>

  <div>
    <div>Downscaled preview (28×28):</div>
    <canvas id="preview" width="28" height="28"></canvas>
    <div id="result" style="margin-top:10px"></div>
  </div>
</div>

<script>
/* ================== Model path ================== */
const MODEL_URL = 'mnist_tfjs_model/model.json'; // change if needed
let model = null;
let cvIsReady = false;

/* ================== Canvas drawing (black bg, white ink) ================== */
const pad = document.getElementById('pad');
const ctx = pad.getContext('2d');
ctx.fillStyle = '#000'; ctx.fillRect(0,0,pad.width,pad.height);
ctx.strokeStyle = '#fff'; ctx.lineWidth = 22; ctx.lineCap = 'round';

let drawing=false, prev=null;
function pos(e){ const r=pad.getBoundingClientRect(); const t=e.touches?e.touches[0]:e; return {x:t.clientX-r.left,y:t.clientY-r.top}; }
function start(e){ drawing=true; prev=pos(e); }
function move(e){ if(!drawing) return; const p=pos(e); ctx.beginPath(); ctx.moveTo(prev.x,prev.y); ctx.lineTo(p.x,p.y); ctx.stroke(); prev=p; }
function end(){ drawing=false; prev=null; }
pad.addEventListener('mousedown',start); pad.addEventListener('mousemove',move); pad.addEventListener('mouseup',end); pad.addEventListener('mouseleave',end);
pad.addEventListener('touchstart',start,{passive:false}); pad.addEventListener('touchmove',e=>{e.preventDefault();move(e)},{passive:false}); pad.addEventListener('touchend',end);

/* ================== OpenCV ready + load model ================== */
function cvReady(){
  cv['onRuntimeInitialized']=async ()=>{
    cvIsReady = true;
    document.getElementById('status').textContent = 'OpenCV ready. Loading TFJS model…';
    try{
      model = await tf.loadGraphModel(MODEL_URL);
      document.getElementById('status').innerHTML =
        'Model loaded ✅ (GraphModel). Inference will use <code>keras_tensor → output_0</code> if available.';
    }catch(err){
      document.getElementById('status').textContent = '❌ Failed to load model: ' + err;
      console.error(err);
    }
  }
}

/* ================== Helpers ================== */
// Choose largest contour (area)
function largestContour(contours){
  let best=null, maxA=-1;
  for(let i=0;i<contours.size();i++){
    const c=contours.get(i), a=cv.contourArea(c,false);
    if(a>maxA){ maxA=a; best=c; }
  }
  return best;
}
// Otsu binarization (white digit on black background → THRESH_BINARY)
function otsuBinary(gray){
  const dst = new cv.Mat();
  cv.threshold(gray, dst, 0, 255, cv.THRESH_BINARY | cv.THRESH_OTSU);
  return dst;
}

/* ============== MNIST-like preprocessing ==============
   Steps: RGBA→GRAY → Otsu → largest contour → crop ROI
          → longest side to 20px → paste into 28×28 at center
          → center-of-mass align → (optional blur) → to [1,784] float in [0,1]
*/
function canvasToMNISTTensor(canvasEl, blurPx=0.5){
  // RGBA→GRAY
  let rgba = cv.imread(canvasEl);
  let gray = new cv.Mat();
  cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY, 0);

  // Otsu threshold (robust to stroke intensity)
  let bin = otsuBinary(gray);

  // Find largest contour
  let contours = new cv.MatVector(), hierarchy = new cv.Mat();
  cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
  const cnt = largestContour(contours);
  if(!cnt){
    rgba.delete(); gray.delete(); bin.delete(); contours.delete(); hierarchy.delete();
    return tf.zeros([1,28*28],'float32');
  }
  const rect = cv.boundingRect(cnt);
  let roi = bin.roi(rect);

  // Resize: longest side → 20 px
  const bw = roi.cols, bh = roi.rows;
  const scale = 20 / Math.max(bw, bh);
  const rsW = Math.max(1, Math.round(bw*scale));
  const rsH = Math.max(1, Math.round(bh*scale));
  let resized = new cv.Mat();
  cv.resize(roi, resized, new cv.Size(rsW, rsH), 0, 0, cv.INTER_AREA);

  // Paste to 28×28 (geometric center)
  let img28 = new cv.Mat.zeros(28,28, cv.CV_8UC1);
  const cx = Math.round((28-rsW)/2);
  const cy = Math.round((28-rsH)/2);
  resized.copyTo(img28.roi(new cv.Rect(cx,cy,rsW,rsH)));

  // Center-of-mass alignment (image moments)
  let m = cv.moments(img28, true);
  const comX = m.m10 / (m.m00 || 1), comY = m.m01 / (m.m00 || 1);
  const shiftX = Math.round(14 - comX), shiftY = Math.round(14 - comY);
  let M = cv.matFromArray(2,3,cv.CV_64F,[1,0,shiftX, 0,1,shiftY]);
  let centered = new cv.Mat();
  cv.warpAffine(img28, centered, M, new cv.Size(28,28), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(0));

  // Optional mild blur to mimic MNIST softness
  if(blurPx>0){
    const k = Math.max(1, 2*Math.round(blurPx)+1); // odd kernel
    cv.GaussianBlur(centered, centered, new cv.Size(k,k), 0);
  }

  // Show preview (28×28)
  const pv = document.getElementById('preview').getContext('2d');
  pv.imageSmoothingEnabled = false;
  const tmp = new cv.Mat(); cv.cvtColor(centered, tmp, cv.COLOR_GRAY2RGBA); // to RGBA for imshow
  const previewCanvas = document.createElement('canvas'); previewCanvas.width=28; previewCanvas.height=28;
  cv.imshow(previewCanvas, tmp); pv.clearRect(0,0,28,28); pv.drawImage(previewCanvas,0,0);
  tmp.delete();

  // To tensor [1,784] in [0,1]
  const data = centered.data; // Uint8Array
  const float = Float32Array.from(data, v => v/255);
  const x = tf.tensor(float, [1,28*28], 'float32');

  // Cleanup
  rgba.delete(); gray.delete(); bin.delete(); contours.delete(); hierarchy.delete();
  roi.delete(); resized.delete(); img28.delete(); centered.delete(); M.delete();

  return x;
}

/* ================== Predict & visualize ================== */
function drawBars(probs){
  const root = document.getElementById('result');
  root.innerHTML = '<h3>Probabilities</h3>';
  const top = probs.map((p,i)=>[i,p]).sort((a,b)=>b[1]-a[1]);
  const best = top[0][0];
  for(let i=0;i<10;i++){
    const row=document.createElement('div'); row.className='row';
    const lab=document.createElement('div'); lab.textContent=i;
    const wrap=document.createElement('div'); const bar=document.createElement('div'); bar.className='bar';
    bar.style.width=(probs[i]*100).toFixed(1)+'%';
    bar.style.background = i===best?'var(--accent)':'var(--bar)';
    const val=document.createElement('div'); val.textContent=(probs[i]*100).toFixed(1)+'%';
    wrap.appendChild(bar); row.appendChild(lab); row.appendChild(wrap); row.appendChild(val); root.appendChild(row);
  }
  const p=document.createElement('div'); p.style.marginTop='8px';
  p.innerHTML='<b>Predicted digit:</b> '+best+' (top-3: '+top.slice(0,3).map(x=>x[0]).join(', ')+')';
  root.appendChild(p);
}

async function predict(){
  if(!cvIsReady || !model){ alert('Model or OpenCV not ready'); return; }
  const blurPx = parseFloat(document.getElementById('blurPx').value || 0.5);
  const x = canvasToMNISTTensor(pad, blurPx);

  let y;
  try{
    // Preferred: named I/O (SavedModel → TFJS graph keeps tensor names)
    y = await model.executeAsync({ keras_tensor: x }, 'output_0');
  }catch(e){
    // Fallback: generic predict
    y = model.predict(x);
  }
  if(Array.isArray(y)) y = y[0];

  const probs = Array.from(await y.data());
  drawBars(probs);
  tf.dispose([x,y]);
}

/* ================== UI ================== */
document.getElementById('btnClear').onclick = ()=>{
  ctx.fillStyle='#000'; ctx.fillRect(0,0,pad.width,pad.height); ctx.fillStyle='#000';
  document.getElementById('result').innerHTML='';
  const pv=document.getElementById('preview').getContext('2d'); pv.clearRect(0,0,28,28);
};
document.getElementById('btnPredict').onclick = predict;
</script>
</body>
</html>
